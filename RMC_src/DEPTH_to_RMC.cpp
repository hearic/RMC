# include "Burnup.h"
# include "Criticality.h"

void CDBurnup::DEPTH_to_RMC(CDMaterial &cMaterial,CDTally &cTally,int nBurnCellIndex)
{
	int nTallyPos = p_nBurnTallyStartPos + nBurnCellIndex ;
	int nMat = cTally.p_vOneGroupCsTally[nTallyPos].p_nMat;
	
	//////////////////////////// updating cell nuclide densities ///////////////////////////////
# ifdef _IS_PARALLEL_
	if(OParallel.p_bIsParallelBurn)
	{
		nBurnCellIndex = nBurnCellIndex - OParallel.p_nStartBurnCellIndex;
	}
# endif

	if(p_nBurnStepStrategy == -1)    // corrector step for pc burnup strategy
	{
		for(int i = 1;i <= Depth.NucNum; ++i)
		{
			p_vCellBurnNucDen[nBurnCellIndex][i] = (Depth.StepNt[Depth.StepNum][i] + p_vCellBurnNucDenPre[nBurnCellIndex][i])/2;   // save all nuclide composition for ORIGEN2
		}
	}
	else
	{
		p_vCellBurnNucDen[nBurnCellIndex] = Depth.StepNt[Depth.StepNum];

		/////////////// Xenon equilibrium treatment //////////////////////
		if(p_nXeEqFlag == 1)
		{
			static int nXeIndex = ConvertNucId("54135");

			if(p_nBurnStep == 0)
			{
				p_vXeEqDen[nBurnCellIndex] = p_vCellBurnNucDen[nBurnCellIndex][nXeIndex];
			}
			else
			{
				double dDelta = p_vCellBurnNucDen[nBurnCellIndex][nXeIndex] - p_vXeEqDen[nBurnCellIndex];
				if( fabs(dDelta) > p_dXeEqFactor * p_vXeEqDen[nBurnCellIndex] )
				{
					if(dDelta > 0)
					{
						dDelta = p_dXeEqFactor * p_vXeEqDen[nBurnCellIndex];
					}
					else
					{
						dDelta = -p_dXeEqFactor * p_vXeEqDen[nBurnCellIndex];
					}
				}

				p_vCellBurnNucDen[nBurnCellIndex][nXeIndex] = p_vXeEqDen[nBurnCellIndex] + dDelta;
				p_vXeEqDen[nBurnCellIndex] = p_vCellBurnNucDen[nBurnCellIndex][nXeIndex];
			}
		}	
	}

	auto &vNt = p_vCellBurnNucDen[nBurnCellIndex];


	////////////////////////// selecting important nuclides from Depth ////////////////////////////
	/////////////////////////// by user input/absorption/Density //////////////////////////////////
	// AtomDen and NucID of nuclides selected are transferred into AtomDen and NucID of materials
	// Remember: 1. NucDens are multiplied by volume; 
	//           2. NucIDs are to be cleared after updating material

	/////////////////////////////////////  setup vectors /////////////////////////////////
	vector<double> vAbsorpFrac(Depth.AbsorpRate[Depth.StepNum]);
	vector<double> vNucDenFrac(vNt);
	vAbsorpFrac[0] = 0 ;
	vNucDenFrac[0] = 0;
	CDGlobeFun::NormalizeVec(vAbsorpFrac);
	CDGlobeFun::NormalizeVec(vNucDenFrac);

	vector<int> vNucSortAbs(Depth.NucNum + 1); 
	vector<int> nNucSortDen(Depth.NucNum + 1); 
	for(int i = 1;i <= Depth.NucNum; ++i) 
	{ 
		vNucSortAbs[i] = i;
		nNucSortDen[i] = i;
	}    

	vector<int> nNucSelected(Depth.NucNum + 1);
	CDGlobeFun::Set1DVecZero(nNucSelected);

	///////////////////////// select nuclides by user input  //////////////////////////////
	double dAbsFracSum = 0;
	double dNucDenFracSum = 0;
	int nInitialNucNum = p_vCellInitNucID[nBurnCellIndex].size();

	cMaterial.p_vMatSet[nMat].p_vMatNucID = p_vCellInitNucID[nBurnCellIndex];
	cMaterial.p_vMatSet[nMat].p_vMatNucAtomDen.resize(nInitialNucNum);

	for(int i = 0 ; i < nInitialNucNum ; ++i )   // type+1
	{
		////// find nuclide nIndex in depth
		int nIndex = ConvertNucId(p_vCellInitNucID[nBurnCellIndex][i].p_chIdStr);
		if(nIndex < 0 ) // for non-depletion nuclide, keep initial density
		{
			//if(nIndex == -1000)
			//{
			cMaterial.p_vMatSet[nMat].p_vMatNucAtomDen[i] = p_vCellInitNucDen[nBurnCellIndex][i];
			//}
			continue;
		}

		cMaterial.p_vMatSet[nMat].p_vMatNucAtomDen[i] = vNt[nIndex];

		nNucSelected[nIndex] = 1;
		dAbsFracSum = dAbsFracSum + vAbsorpFrac[nIndex];
		dNucDenFracSum = dNucDenFracSum + vNucDenFrac[nIndex];
	}

	///////////////////////// select nuclides by ImpNucId list  //////////////////////////////
	for(int i = 0 ; i < p_vImpNucIndex.size(); ++i)
	{
		int nIndex = p_vImpNucIndex[i];
		if(nNucSelected[nIndex] == 1)  // nuclide j has been selected in previous stage
		{
			continue;
		}  
		//// add nuclide to material
		int nNucId = Depth.GetNucId(nIndex);
		double nNucDen = vNt[nIndex];
		AddBurnNucToMat(nNucId, nNucDen, cMaterial.p_vMatSet[nMat]);

		//// sum fraction
		nNucSelected[nIndex] = 1;
		dAbsFracSum = dAbsFracSum + vAbsorpFrac[nIndex];
		dNucDenFracSum = dNucDenFracSum + vNucDenFrac[nIndex];
	}	

	///////////////////////// select nuclides by absorption fraction //////////////////////////////
	// for zero power case (decay only mode), vAbsorpFrac is zero, skip selection by absorption
	// TODO: large absorption nuclide generated by decay may miss in this case
	if (dAbsFracSum < p_dAbsorpFracCutoff && CDGlobeFun::SumupVec(vAbsorpFrac) != 0 && nMat != 0 )
	{
		CDGlobeFun::SortTwoVec(vAbsorpFrac,1,Depth.NucNum,vNucSortAbs);
		for(int i = 1; i <= Depth.NucNum; ++i ) 
		{
			int nIndex = vNucSortAbs[i];
			if(nNucSelected[nIndex] == 1)  // nuclide j has been selected in previous stage
			{
				continue;
			}  

			nNucSelected[nIndex] = 1;
			dAbsFracSum = dAbsFracSum + vAbsorpFrac[i];
			dNucDenFracSum = dNucDenFracSum + vNucDenFrac[nIndex];

			if(p_vNucAceExist[nIndex])                   // The nuclide exists in xsdir
			{
				//// add nuclide to material
				int nNucId = Depth.GetNucId(nIndex);
				double nNucDen = vNt[nIndex];
				AddBurnNucToMat(nNucId, nNucDen, cMaterial.p_vMatSet[nMat]);
			}
			if(dAbsFracSum >= p_dAbsorpFracCutoff)
			{
				break;
			}
		}
	}	

	///////////////////////// select nuclides by density fraction //////////////////////////////
	if(dNucDenFracSum < p_dNucDenFracCutoff && CDGlobeFun::SumupVec(vNucDenFrac) != 0 && nMat != 0)
	{
		CDGlobeFun::SortTwoVec(vNucDenFrac,1,Depth.NucNum,nNucSortDen);
		for(int i = 1; i <= Depth.NucNum; ++i )  
		{
			int nIndex = nNucSortDen[i];
			if(nNucSelected[nIndex] == 1)  // nuclide j has been selected in previous stage
			{
				continue;
			}  

			nNucSelected[nIndex] = 1;
			dNucDenFracSum = dNucDenFracSum + vNucDenFrac[i];

			if(p_vNucAceExist[nIndex])                   // The nuclide exists in xsdir
			{
				//// add nuclide to material
				int nNucId = Depth.GetNucId(nIndex);
				double nNucDen = vNt[nIndex];
				AddBurnNucToMat(nNucId, nNucDen, cMaterial.p_vMatSet[nMat]);
			}
			if(dNucDenFracSum >= p_dNucDenFracCutoff)
			{
				break;
			}
		}
	}	

	int mat_tot_nuc_num = cMaterial.p_vMatSet[nMat].p_vMatNucID.size();
	cMaterial.p_vMatSet[nMat].p_dMatTotNucNum = mat_tot_nuc_num;

	return;
}

